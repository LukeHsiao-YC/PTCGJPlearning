<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯¶å¯å¤¢å¡ç‰Œå°è€å¸«</title>
    <!-- å¼•å…¥ Tailwind CSS è®“ç•«é¢æ’ç‰ˆæ›´æ–¹ä¾¿ç¾è§€ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥ React å’Œ ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- å¼•å…¥ Babel ä¾†ç·¨è­¯ JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- å¼•å…¥ Lucide Icons ä½œç‚ºæŒ‰éˆ•åœ–ç¤º -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* æ›¿ç¶²é åŠ é»å¯æ„›çš„èƒŒæ™¯è·Ÿå­—é«”è¨­å®š */
        body {
            font-family: 'Nunito', 'Noto Sans TC', sans-serif;
            background-color: #f0f9ff;
            background-image: radial-gradient(#bae6fd 2px, transparent 2px);
            background-size: 30px 30px;
        }
        .poke-shadow {
            box-shadow: 0 10px 25px -5px rgba(59, 130, 246, 0.5);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // Gemini API é‡‘é‘° (ç’°å¢ƒæœƒè‡ªå‹•å¸¶å…¥)
        const apiKey = "";

        function App() {
            // æ‡‰ç”¨ç¨‹å¼çš„ç‹€æ…‹ç®¡ç†ï¼šcamera (ç›¸æ©Ÿæ¨¡å¼), analyzing (åˆ†æä¸­), result (é¡¯ç¤ºçµæœ), error (éŒ¯èª¤)
            const [appState, setAppState] = useState('camera');
            const [words, setWords] = useState([]);
            const [capturedImage, setCapturedImage] = useState(null);
            const [errorMessage, setErrorMessage] = useState('');
            
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const streamRef = useRef(null);

            // å•Ÿå‹•ç›¸æ©Ÿ
            const startCamera = async () => {
                try {
                    setAppState('camera');
                    setErrorMessage('');
                    // å„ªå…ˆä½¿ç”¨å¾Œç½®é¡é ­ï¼Œä¸¦è¦æ±‚è¼ƒé«˜çš„è§£æåº¦ä¾†å¹«åŠ©å°ç„¦
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            facingMode: 'environment',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 }
                        } 
                    });
                    if (videoRef.current) {
                        videoRef.current.srcObject = stream;
                    }
                    streamRef.current = stream;
                } catch (err) {
                    console.error("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—:", err);
                    setErrorMessage("å“å‘€ï¼æ²’è¾¦æ³•é–‹å•Ÿç›¸æ©Ÿï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨çš„æ¬Šé™è¨­å®šå–”ã€‚");
                    setAppState('error');
                }
            };

            // é—œé–‰ç›¸æ©Ÿ (é‡‹æ”¾è³‡æº)
            const stopCamera = () => {
                if (streamRef.current) {
                    streamRef.current.getTracks().forEach(track => track.stop());
                }
            };

            // å…ƒä»¶è¼‰å…¥æ™‚å•Ÿå‹•ç›¸æ©Ÿï¼Œå¸è¼‰æ™‚é—œé–‰ç›¸æ©Ÿ
            useEffect(() => {
                startCamera();
                return () => stopCamera();
            }, []);

            // æ‹ç…§ä¸¦å‚³é€çµ¦ AI åˆ†æ
            const takePhoto = async () => {
                if (!videoRef.current || !canvasRef.current) return;

                const video = videoRef.current;
                const canvas = canvasRef.current;
                
                // è¨­å®šç•«å¸ƒå¤§å°èˆ‡å½±ç‰‡ä¾†æºä¸€è‡´
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // å°‡å½±ç‰‡ç›®å‰çš„ç•«é¢ç•«åˆ°ç•«å¸ƒä¸Š
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // å–å¾— base64 æ ¼å¼çš„åœ–ç‰‡è³‡æ–™ (JPEGæ ¼å¼)
                const imageDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                setCapturedImage(imageDataUrl);
                
                // åœæ­¢ç›¸æ©Ÿä¸¦é€²å…¥åˆ†æç‹€æ…‹
                stopCamera();
                setAppState('analyzing');

                // ç§»é™¤ "data:image/jpeg;base64," å‰ç¶´ï¼Œåªä¿ç•™ç´” base64 å…§å®¹çµ¦ API
                const base64Data = imageDataUrl.split(',')[1];
                analyzeCard(base64Data);
            };

            // å‘¼å« Gemini API åˆ†æå¡ç‰Œ
            const analyzeCard = async (base64Image) => {
                try {
                    const prompt = `
                        é€™æ˜¯ä¸€å¼µæ—¥æ–‡å¯¶å¯å¤¢å¡ç‰Œçš„ç…§ç‰‡ã€‚ä½ ç¾åœ¨æ˜¯ä¸€å€‹å……æ»¿ç†±æƒ…ã€å°ˆé–€æ•™å°å­©æ—¥æ–‡çš„è€å¸«ã€‚
                        è«‹å¾é€™å¼µå¡ç‰Œä¸­ï¼ŒæŒ‘é¸å‡º 2 åˆ° 3 å€‹æœ€é©åˆåˆå­¸è€…å°å­©å­¸ç¿’çš„æ—¥æ–‡å–®å­—ã€‚
                        å„ªå…ˆæŒ‘é¸ã€Œå¯¶å¯å¤¢çš„åå­—ã€æˆ–æ˜¯ã€Œç°¡å–®çš„æ‹›å¼åç¨±ã€ã€‚
                        è«‹å›å‚³ JSON æ ¼å¼çš„é™£åˆ—ã€‚
                    `;

                    // API è«‹æ±‚çš„ Payloadï¼Œè¦æ±‚å›å‚³åš´æ ¼çš„ JSON æ ¼å¼
                    const payload = {
                        contents: [{
                            role: "user",
                            parts: [
                                { text: prompt },
                                { inlineData: { mimeType: "image/jpeg", data: base64Image } }
                            ]
                        }],
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        word: { type: "STRING", description: "å¡ç‰Œä¸Šçš„æ—¥æ–‡å–®å­— (æ¼¢å­—æˆ–ç‰‡å‡å/å¹³å‡å)" },
                                        kana: { type: "STRING", description: "é€™å€‹å–®å­—çš„å¹³å‡åè®€éŸ³ (è®“å°å­©çŸ¥é“æ€éº¼å”¸)" },
                                        meaning: { type: "STRING", description: "ç¹é«”ä¸­æ–‡çš„ç¿»è­¯æˆ–æ„æ€" }
                                    },
                                    required: ["word", "kana", "meaning"]
                                }
                            }
                        }
                    };

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API ç™¼ç”ŸéŒ¯èª¤: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    // è§£æ AI å›å‚³çš„ JSON æ–‡å­—
                    const resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (resultText) {
                        const parsedWords = JSON.parse(resultText);
                        setWords(parsedWords);
                        setAppState('result');
                    } else {
                        throw new Error("æ‰¾ä¸åˆ°è¾¨è­˜çµæœ");
                    }

                } catch (err) {
                    console.error("åˆ†æå¤±æ•—:", err);
                    setErrorMessage("å“å‘€ï¼å‰›å‰›ç…§ç‰‡æœ‰é»æ¨¡ç³Šï¼Œå°è€å¸«æ²’æœ‰çœ‹æ¸…æ¥šå¡ç‰Œä¸Šçš„å­—ï¼Œå¯ä»¥æ‹¿é ä¸€é»é»å†è©¦ä¸€æ¬¡å—ï¼Ÿ");
                    setAppState('error');
                }
            };

            // é‡æ–°é–‹å§‹
            const resetApp = () => {
                setWords([]);
                setCapturedImage(null);
                startCamera();
            };

            return (
                <div className="min-h-screen flex flex-col items-center justify-center p-4">
                    
                    <div className="max-w-md w-full bg-white rounded-3xl p-6 poke-shadow border-4 border-yellow-400 relative overflow-hidden">
                        
                        {/* é ‚éƒ¨è£é£¾æ¨™é¡Œ */}
                        <div className="text-center mb-6">
                            <h1 className="text-2xl font-black text-blue-600 tracking-wider">
                                ğŸ” å¯¶å¯å¤¢æƒææ©Ÿ
                            </h1>
                            <p className="text-red-500 font-bold text-sm mt-1">å°ç§˜è¨£ï¼šå¦‚æœå¤ªè¿‘æœƒæ¨¡ç³Šï¼Œè«‹æ‹¿é ä¸€é»é»å–”ï¼</p>
                        </div>

                        {/* ç›¸æ©Ÿæ¨¡å¼ */}
                        <div className={appState === 'camera' ? 'block' : 'hidden'}>
                            <div className="relative rounded-2xl overflow-hidden border-4 border-blue-200 bg-gray-100 aspect-[3/4] flex items-center justify-center">
                                <video 
                                    ref={videoRef} 
                                    autoPlay 
                                    playsInline 
                                    muted 
                                    className="absolute inset-0 w-full h-full object-cover"
                                ></video>
                                {/* éš±è—çš„ç•«å¸ƒç”¨ä¾†æˆªåœ– */}
                                <canvas ref={canvasRef} className="hidden"></canvas>
                                
                                {/* è¼”åŠ©å°é½Šçš„æ¡†ç·š */}
                                <div className="absolute inset-4 border-2 border-dashed border-white/70 rounded-xl pointer-events-none"></div>
                            </div>

                            <button 
                                onClick={takePhoto}
                                className="mt-8 w-full bg-red-500 hover:bg-red-600 active:bg-red-700 text-white font-bold py-4 rounded-full text-xl transition-transform active:scale-95 shadow-lg flex items-center justify-center gap-2"
                            >
                                <i data-lucide="camera" className="w-6 h-6"></i>
                                å–€åš“ï¼æƒæå¡ç‰Œ
                            </button>
                        </div>

                        {/* è¼‰å…¥/åˆ†æä¸­ç‹€æ…‹ */}
                        {appState === 'analyzing' && (
                            <div className="flex flex-col items-center justify-center py-12">
                                <div className="w-20 h-20 border-8 border-gray-200 border-t-red-500 rounded-full animate-spin mb-6"></div>
                                <h2 className="text-xl font-bold text-gray-700 animate-pulse">å°è€å¸«æ­£åœ¨çœ‹å¡ç‰Œ...</h2>
                                <p className="text-gray-500 mt-2">æ‰¾æ‰¾çœ‹æœ‰æ²’æœ‰å¥½ç©çš„å–®å­—ï¼</p>
                            </div>
                        )}

                        {/* çµæœé¡¯ç¤ºç‹€æ…‹ */}
                        {appState === 'result' && (
                            <div className="animate-fade-in flex flex-col items-center">
                                <div className="w-32 h-32 rounded-xl overflow-hidden mb-6 border-4 border-yellow-300 shadow-md">
                                    <img src={capturedImage} alt="Captured Card" className="w-full h-full object-cover" />
                                </div>
                                
                                <div className="w-full space-y-4">
                                    {words.map((item, index) => (
                                        <div key={index} className="bg-blue-50 rounded-2xl p-4 border-2 border-blue-100 relative">
                                            <div className="absolute -top-3 -left-3 bg-yellow-400 text-yellow-900 w-8 h-8 rounded-full flex items-center justify-center font-bold text-sm border-2 border-white">
                                                {index + 1}
                                            </div>
                                            <div className="text-center">
                                                {/* æ³¨éŸ³/å¹³å‡å */}
                                                <p className="text-blue-500 font-medium mb-1 tracking-widest">{item.kana}</p>
                                                {/* æ—¥æ–‡å–®å­— */}
                                                <h3 className="text-3xl font-black text-gray-800 mb-2">{item.word}</h3>
                                                {/* ä¸­æ–‡æ„æ€ */}
                                                <div className="inline-block bg-white px-4 py-1 rounded-full text-gray-600 font-bold border border-gray-200 shadow-sm">
                                                    {item.meaning}
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>

                                <button 
                                    onClick={resetApp}
                                    className="mt-8 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 rounded-full text-lg transition-transform active:scale-95 shadow-lg"
                                >
                                    æƒæä¸‹ä¸€å¼µå¡ç‰Œï¼
                                </button>
                            </div>
                        )}

                        {/* éŒ¯èª¤ç‹€æ…‹ */}
                        {appState === 'error' && (
                            <div className="text-center py-8">
                                <div className="text-5xl mb-4">ğŸ˜¢</div>
                                <p className="text-lg font-bold text-gray-700 mb-6">{errorMessage}</p>
                                <button 
                                    onClick={resetApp}
                                    className="bg-yellow-400 hover:bg-yellow-500 text-yellow-900 font-bold py-3 px-8 rounded-full shadow-sm"
                                >
                                    é‡æ–°è©¦è©¦çœ‹
                                </button>
                            </div>
                        )}

                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

        // åˆå§‹åŒ–åœ–ç¤º
        lucide.createIcons();
    </script>
</body>
</html>
